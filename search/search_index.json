{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 Institutions manage vast amounts of data, often reaching petabyte scales across multiple Linux-based storage servers. Users storing data in these systems need a streamlined way to modify ACLs to grant or revoke access for collaborators. Currently, the IT teams at such institutions are responsible for manually handling these ACL modifications, which is time-consuming, error-prone, and inefficient, especially as data volume and user demands grow. To address this challenge, a Web Management Interface is built to allow users to modify ACLs securely. This system eliminates the burden on IT teams by enabling on-demand permission management while ensuring security and reliability. The system features a robust and highly configurable backend, high-speed databases, orchestration daemons for file storage servers, and an intuitive frontend. About \u00b6 Contributions \u00b6 Contributor: Aditya Patil Mentors : Robert Tweedy Mahmoud Zeydabadinezhad, PhD Acknowledgements \u00b6 Department of Biomedical Informatics, Emory University Google Summer of Code 2025 Program This project is licensed under the MIT License - see the LICENSE file for details.","title":"Home"},{"location":"#introduction","text":"Institutions manage vast amounts of data, often reaching petabyte scales across multiple Linux-based storage servers. Users storing data in these systems need a streamlined way to modify ACLs to grant or revoke access for collaborators. Currently, the IT teams at such institutions are responsible for manually handling these ACL modifications, which is time-consuming, error-prone, and inefficient, especially as data volume and user demands grow. To address this challenge, a Web Management Interface is built to allow users to modify ACLs securely. This system eliminates the burden on IT teams by enabling on-demand permission management while ensuring security and reliability. The system features a robust and highly configurable backend, high-speed databases, orchestration daemons for file storage servers, and an intuitive frontend.","title":"Introduction"},{"location":"#about","text":"","title":"About"},{"location":"#contributions","text":"Contributor: Aditya Patil Mentors : Robert Tweedy Mahmoud Zeydabadinezhad, PhD","title":"Contributions"},{"location":"#acknowledgements","text":"Department of Biomedical Informatics, Emory University Google Summer of Code 2025 Program This project is licensed under the MIT License - see the LICENSE file for details.","title":"Acknowledgements"},{"location":"00_getting_started/installation/","text":"Warning: Project is under development and requirements might change frequently! Given requirements are based on experience of developers and calculations. More accurate requirements will be listed as the project is adopted more. System Requirements \u00b6 Backend Component \u00b6 To run the Linux ACL Management Backend, ensure your system meets the following requirements and has the necessary dependencies installed. Operating System \u00b6 Linux (recommended for production) macOS and Windows (for development/testing; some features may require adaptation) Hardware \u00b6 Minimum: 2 CPU cores, 2GB RAM (for development/testing) Recommended: 4+ CPU cores, 8GB+ RAM (for production, especially with large organizations or many users) Software Dependencies \u00b6 Go (Golang) Version: 1.20 or higher (Go 1.24.x recommended) Used to build and run the backend application. Redis Used for transaction logging and session management. Version: 6.x or higher recommended. PostgreSQL Used for archival and persistent storage of transaction data. Version: 13.x or higher recommended. LDAP (OpenLDAP is used for testing) Required for authentication and user management. Version: Any recent stable version. Docker (optional for development purposes) For running the application and dependencies in containers. Version: 20.x or higher. Docker Compose (optional for development purposes) For orchestrating multi-container setups (app, Redis, OpenLDAP, etc.). Version: 1.29+ or Docker Compose V2. Bash & ACL utilities bash: Required in the container for scripting. acl: Required for manipulating Access Control Lists on Linux filesystems. Other Tools (for development) make: For building the project using the provided Makefile. jq: For parsing JSON in test scripts. curl: For API testing. Network & Ports \u00b6 8080/tcp: Default API server port 389/tcp, 636/tcp: OpenLDAP 6379/tcp: Redis 5432/tcp: PostgreSQL 8090/tcp: phpLDAPadmin (optional, for LDAP management UI) Filesystem \u00b6 Access to the target filesystems (e.g., NFS, BeeGFS) is required for ACL management. Ensure the backend has the necessary permissions to modify ACLs on the managed paths. Environment Variables \u00b6 Sensitive configuration (e.g., Redis password, LDAP admin DN/password, JWT secret) should be provided via environment variables or a .env file. Optional: Docker Compose \u00b6 For advanced testing, a BeeGFS/NFS environment can be spun up using the provided docker-compose.beegfs.yaml. Information: Advanced playground with Docker Compose is under development for learning/development purposes ACL API Daemon \u00b6 To run the Linux ACL Management API Daemon, ensure your system meets the following requirements and has the necessary dependencies installed. Following are the requirements for production mode . Operating System \u00b6 Linux (recommended for production) Hardware \u00b6 CPU: 1+ core (x86_64/ARM64) RAM: 256MB minimum (512MB+ recommended) Disk: 50MB free space (for binary, logs, and config) Software \u00b6 Systemd or compatible init system (for running as a service) OpenSSL (for TLS, if enabled) Network access to host gRPC server (for communication with backend) Configuration \u00b6 aclapi.yaml configuration file (must be present and properly configured) Certificates in cert/ directory (if using TLS) Proper permissions for log and config directories Following are the requirements for development mode . Software \u00b6 Go 1.20+ (see go.mod for exact version) Make (for using provided Makefile) Git (for source control) Development Tools (Recommendations) \u00b6 golangci-lint (for linting) go test (for running tests) Any editor/IDE with Go support Other \u00b6 Access to test certificates (for local TLS testing) Sample configuration files (provided with the code in the official repository) ACL Core Daemon \u00b6 To run the Linux ACL Management Core Daemon, ensure your system meets the following requirements and has the necessary dependencies installed. Following are the requirements for production mode . Operating System \u00b6 Linux (recommended for production) Hardware \u00b6 CPU: 1+ core (x86_64/ARM64) RAM: 256MB minimum (512MB+ recommended) Disk: 50MB free space (for binary, logs, and config) Software \u00b6 Systemd or compatible init system (for running as a service) Adequate permissions to change ACL permissions on behalf of root/users Configuration \u00b6 aclcore.yaml configuration file (must be present and properly configured) Proper permissions for log and config directories Following are the requirements for development mode . Software \u00b6 Go 1.20+ (see go.mod for exact version) Make (for using provided Makefile) Git (for source control) Development Tools (Recommendations) \u00b6 golangci-lint (for linting) go test (for running tests) Any editor/IDE with Go support Other \u00b6 Access to test certificates (for local TLS testing) Sample configuration files (provided with the code in the official repository) Additional Guidelines for Daemons \u00b6 Both daemons are designed to be run as background services (systemd unit files are provided). For production, ensure proper firewall and security settings. For development, you may need to install additional Go tools as specified in the Makefile or README. Note: The API and Core daemons are highly dependent on each other to complete the their purpose as permission modification daemons. It's a good practice to deploy them together for better configuration.","title":"Installation"},{"location":"00_getting_started/installation/#system-requirements","text":"","title":"System Requirements"},{"location":"00_getting_started/installation/#backend-component","text":"To run the Linux ACL Management Backend, ensure your system meets the following requirements and has the necessary dependencies installed.","title":"Backend Component"},{"location":"00_getting_started/installation/#operating-system","text":"Linux (recommended for production) macOS and Windows (for development/testing; some features may require adaptation)","title":"Operating System"},{"location":"00_getting_started/installation/#hardware","text":"Minimum: 2 CPU cores, 2GB RAM (for development/testing) Recommended: 4+ CPU cores, 8GB+ RAM (for production, especially with large organizations or many users)","title":"Hardware"},{"location":"00_getting_started/installation/#software-dependencies","text":"Go (Golang) Version: 1.20 or higher (Go 1.24.x recommended) Used to build and run the backend application. Redis Used for transaction logging and session management. Version: 6.x or higher recommended. PostgreSQL Used for archival and persistent storage of transaction data. Version: 13.x or higher recommended. LDAP (OpenLDAP is used for testing) Required for authentication and user management. Version: Any recent stable version. Docker (optional for development purposes) For running the application and dependencies in containers. Version: 20.x or higher. Docker Compose (optional for development purposes) For orchestrating multi-container setups (app, Redis, OpenLDAP, etc.). Version: 1.29+ or Docker Compose V2. Bash & ACL utilities bash: Required in the container for scripting. acl: Required for manipulating Access Control Lists on Linux filesystems. Other Tools (for development) make: For building the project using the provided Makefile. jq: For parsing JSON in test scripts. curl: For API testing.","title":"Software Dependencies"},{"location":"00_getting_started/installation/#network-ports","text":"8080/tcp: Default API server port 389/tcp, 636/tcp: OpenLDAP 6379/tcp: Redis 5432/tcp: PostgreSQL 8090/tcp: phpLDAPadmin (optional, for LDAP management UI)","title":"Network &amp; Ports"},{"location":"00_getting_started/installation/#filesystem","text":"Access to the target filesystems (e.g., NFS, BeeGFS) is required for ACL management. Ensure the backend has the necessary permissions to modify ACLs on the managed paths.","title":"Filesystem"},{"location":"00_getting_started/installation/#environment-variables","text":"Sensitive configuration (e.g., Redis password, LDAP admin DN/password, JWT secret) should be provided via environment variables or a .env file.","title":"Environment Variables"},{"location":"00_getting_started/installation/#optional-docker-compose","text":"For advanced testing, a BeeGFS/NFS environment can be spun up using the provided docker-compose.beegfs.yaml. Information: Advanced playground with Docker Compose is under development for learning/development purposes","title":"Optional: Docker Compose"},{"location":"00_getting_started/installation/#acl-api-daemon","text":"To run the Linux ACL Management API Daemon, ensure your system meets the following requirements and has the necessary dependencies installed. Following are the requirements for production mode .","title":"ACL API Daemon"},{"location":"00_getting_started/installation/#operating-system_1","text":"Linux (recommended for production)","title":"Operating System"},{"location":"00_getting_started/installation/#hardware_1","text":"CPU: 1+ core (x86_64/ARM64) RAM: 256MB minimum (512MB+ recommended) Disk: 50MB free space (for binary, logs, and config)","title":"Hardware"},{"location":"00_getting_started/installation/#software","text":"Systemd or compatible init system (for running as a service) OpenSSL (for TLS, if enabled) Network access to host gRPC server (for communication with backend)","title":"Software"},{"location":"00_getting_started/installation/#configuration","text":"aclapi.yaml configuration file (must be present and properly configured) Certificates in cert/ directory (if using TLS) Proper permissions for log and config directories Following are the requirements for development mode .","title":"Configuration"},{"location":"00_getting_started/installation/#software_1","text":"Go 1.20+ (see go.mod for exact version) Make (for using provided Makefile) Git (for source control)","title":"Software"},{"location":"00_getting_started/installation/#development-tools-recommendations","text":"golangci-lint (for linting) go test (for running tests) Any editor/IDE with Go support","title":"Development Tools (Recommendations)"},{"location":"00_getting_started/installation/#other","text":"Access to test certificates (for local TLS testing) Sample configuration files (provided with the code in the official repository)","title":"Other"},{"location":"00_getting_started/installation/#acl-core-daemon","text":"To run the Linux ACL Management Core Daemon, ensure your system meets the following requirements and has the necessary dependencies installed. Following are the requirements for production mode .","title":"ACL Core Daemon"},{"location":"00_getting_started/installation/#operating-system_2","text":"Linux (recommended for production)","title":"Operating System"},{"location":"00_getting_started/installation/#hardware_2","text":"CPU: 1+ core (x86_64/ARM64) RAM: 256MB minimum (512MB+ recommended) Disk: 50MB free space (for binary, logs, and config)","title":"Hardware"},{"location":"00_getting_started/installation/#software_2","text":"Systemd or compatible init system (for running as a service) Adequate permissions to change ACL permissions on behalf of root/users","title":"Software"},{"location":"00_getting_started/installation/#configuration_1","text":"aclcore.yaml configuration file (must be present and properly configured) Proper permissions for log and config directories Following are the requirements for development mode .","title":"Configuration"},{"location":"00_getting_started/installation/#software_3","text":"Go 1.20+ (see go.mod for exact version) Make (for using provided Makefile) Git (for source control)","title":"Software"},{"location":"00_getting_started/installation/#development-tools-recommendations_1","text":"golangci-lint (for linting) go test (for running tests) Any editor/IDE with Go support","title":"Development Tools (Recommendations)"},{"location":"00_getting_started/installation/#other_1","text":"Access to test certificates (for local TLS testing) Sample configuration files (provided with the code in the official repository)","title":"Other"},{"location":"00_getting_started/installation/#additional-guidelines-for-daemons","text":"Both daemons are designed to be run as background services (systemd unit files are provided). For production, ensure proper firewall and security settings. For development, you may need to install additional Go tools as specified in the Makefile or README. Note: The API and Core daemons are highly dependent on each other to complete the their purpose as permission modification daemons. It's a good practice to deploy them together for better configuration.","title":"Additional Guidelines for Daemons"},{"location":"00_getting_started/project_structure/","text":"Introduction to Linux ACLs \u00b6 Access Control Lists (ACLs) are very useful when managing access to various files on a Linux system. ACLs are used to provide a more flexible permission mechanism than the traditional owner/group/other model defined by standard Unix file permissions. With ACLs, you can define fine-grained permissions for multiple users and groups on a single file or directory. For example, you might want to allow one specific user to have read-only access to a file while giving another user write access, without changing the file\u2019s primary owner or group. ACLs make this possible by allowing you to add additional permission entries that override or extend the standard permission bits. ACLs are managed using tools like setfacl to set or modify permissions and getfacl to view the current ACL settings. They are particularly useful in collaborative environments where different users or teams need different levels of access to the same files or directories. By using ACLs, system administrators can implement more precise access controls, enhancing both security and usability on shared systems. The Linux ACL Management System \u00b6 The Linux ACL Management System provides an interface that allows users to modify ACL permissions on multiple Linux-based file servers. Institutions often have multiple file servers that provide a remote file system mounted on client machines, enabling users to access shared resources seamlessly. With the ACL Management System, administrators and authorized users can centrally manage detailed file and directory permissions across these servers, ensuring that individuals and groups have the appropriate level of access. This helps maintain security, simplifies permission management in complex environments, and supports collaborative work by allowing fine-grained control over who can read, write, or execute specific files, regardless of the underlying server structure. Ideally, institutions have mutliple Linux servers which hosts filesystems like NFS, BeeGFS, etc. where files are stored by multiple users and they need to share access of the files with other users and collaborators. The Linux ACL Management System allows IT team to set up one unified management setup (for example, a single server or multiple servers working together) that can manage file permissions on multiple file servers on demand. Linux ACL Management does this by utilizing 3 components, namely the backend, frontend, file server daemons. Each of them carry out a different responsibility and work together to make this possible. Show below is the high level architecture of the Linux ACL Management Project: Backend Component \u00b6 The backend component is responsible for managing sessions and transactions, serving endpoints for frontend to control it, communicate with remote daemon components for managing file system permissions, etc. It needs to be installed on a Linux server which has access to all the file system servers in the network and have all these file systems mounted on it (for example, /mnt/nfs-mount). Terminologies \u00b6 Sessions \u00b6 Sessions are created by users who authenticate with the backend. Each session holds information related to the authenticated user and acts as a container for transactions that are scheduled and queued within it. Every session has a unique Session ID, which serves as an identifier for tracking session details, the associated user, and all related transactions. In addition to transaction data, sessions also store user-specific metadata, such as IP address and browser information. Each session is assigned an expiry timer. This timer ensures that a session automatically closes if there is no activity for a specified duration. However, the timer is paused while transactions are actively being processed, and resets once all transactions are complete. When a session expires, the user must authenticate again to create a new session. This mechanism helps frontends automatically sign users out when inactive, improving security and freeing up backend resources by cleaning up unused sessions. It ensures efficient session lifecycle management while balancing user convenience and system performance. Transactions \u00b6 A transaction contains the ACL operation that a user wants to execute. For example, a transaction might specify that Aditya wants to grant Alice read and write permissions to /data/mri-results/mri.scan . Each transaction includes all the details required by the transaction executor to process the ACL command and return the result. Every transaction has a unique Transaction ID and is linked to the Session ID of the session that created it. Using the Transaction ID, you can trace back to the session that scheduled the transaction, and ultimately to the user who initiated it, along with all related session and user information. This structure ensures clear traceability, accountability, and accurate execution of ACL changes across the system. Components it depends on \u00b6 Redis \u00b6 Redis is an open-source, in-memory data store that can be used as a database, cache, and message broker. It is known for its high performance, low latency, and simplicity, making it ideal for real-time applications. In this system, Redis acts as a mirror or intermediary for storing information about sessions and transactions. When streaming data to the frontend, the application fetches this information from Redis instead of directly querying the backend database. This approach helps reduce resource locking in the backend, where sessions and transactions are actively processed. When the frontend requests data, it needs to receive a quick response, often requiring frequent and repeated reads whenever changes occur. If these reads were handled directly by the backend, they could lock critical resources each time, potentially degrading performance especially when many users request data simultaneously. By using Redis, the backend can publish updates as soon as changes occur. The frontend can then fetch the required data from Redis as often as needed without placing additional load on the backend. This decouples read operations from the backend\u2019s transactional workload, ensuring high responsiveness for users while maintaining backend performance. Redis\u2019s efficiency in handling rapid reads and writes makes it an excellent fit for this use case. PostgreSQL \u00b6 PostgreSQL is a powerful, open-source, object-relational database management system known for its stability, advanced features, and standards compliance. It\u2019s widely used for applications ranging from small web apps to large, mission-critical systems that require strong data integrity and scalability. PostgreSQL in Linux ACL Management System is used as an archival database. When a session expires, it's complete information and all it's transactions information is stored into it. In case where the backend is attempted to shutdown when active sessions exist and transactions are processing, the backend first expires all the sessions and stores all the information about session and transactions into this archive. Transactions that weren't processed are marked as pending and are stored in the archive. Linux File Servers \u00b6 BeeGFS File System \u00b6 BeeGFS (BeeGFS stands for BeeGFS: the Berlin Exascale File System) is a high-performance, parallel file system designed for demanding environments like HPC clusters and research institutions. It allows large amounts of data to be distributed across multiple servers, providing fast access and scalability. When BeeGFS is mounted on a Linux system (typically via a client node), files and directories appear as part of the local file system hierarchy. Linux ACL changes on BeeGFS-mounted directories can be executed just like on any other local file system using standard Linux ACL tools such as setfacl and getfacl . The Linux ACL Management System interacts with these tools and apply permission changes consistently, ensuring that access rights are enforced across all nodes and users accessing the shared BeeGFS storage. NFS File System \u00b6 NFS (Network File System) is a widely used protocol that allows files and directories to be shared and accessed over a network as if they were on the local machine. Filesystems like NFS doesn't support running ACL permissions on mount points. In this case, Linux ACL Management System needs direct access to the host Linux file server where it can executed setfacl to modify ACLs. For this purpose, the backend utilizes the daemon component which executes setfacl on the demands of the backend securely. Daemons \u00b6 The Daemon component is used by the backend component to execute setfacl on locally on remote Linux file servers. When the backend realises that the provided file by the user belongs to a file system which demands setfacl to be executed on locally, it communicates with the daemon and gets the command executed to make the ACL change. The daemon component is divided into 2 Linux daemons: ACL API Daemon and ACL Core Daemon. Both of them are installed on the same system and they are highly dependent on each other to function as expected. ACL API Daemon \u00b6 The API Daemon provides a gRPC endpoint for the backend to communicate with it and provides intructions about ACL modifications. This communication is done in very secure manner. It then decodes data provided by the backend server and forwards it to ACL Core daemon via Unix sockets. The ACL API Daemon has very less privileges in the system to ensure security since it's exposed to the network. ACL Core Daemon \u00b6 The ACL Core Daemon takes instructions from ACL API Daemon, executes setfacl on behalf of the user, and returns the response back. It is isolated from external network and communicated only with ACL API Daemon through Unix sockets. Frontend Component \u00b6","title":"Project Structure"},{"location":"00_getting_started/project_structure/#introduction-to-linux-acls","text":"Access Control Lists (ACLs) are very useful when managing access to various files on a Linux system. ACLs are used to provide a more flexible permission mechanism than the traditional owner/group/other model defined by standard Unix file permissions. With ACLs, you can define fine-grained permissions for multiple users and groups on a single file or directory. For example, you might want to allow one specific user to have read-only access to a file while giving another user write access, without changing the file\u2019s primary owner or group. ACLs make this possible by allowing you to add additional permission entries that override or extend the standard permission bits. ACLs are managed using tools like setfacl to set or modify permissions and getfacl to view the current ACL settings. They are particularly useful in collaborative environments where different users or teams need different levels of access to the same files or directories. By using ACLs, system administrators can implement more precise access controls, enhancing both security and usability on shared systems.","title":"Introduction to Linux ACLs"},{"location":"00_getting_started/project_structure/#the-linux-acl-management-system","text":"The Linux ACL Management System provides an interface that allows users to modify ACL permissions on multiple Linux-based file servers. Institutions often have multiple file servers that provide a remote file system mounted on client machines, enabling users to access shared resources seamlessly. With the ACL Management System, administrators and authorized users can centrally manage detailed file and directory permissions across these servers, ensuring that individuals and groups have the appropriate level of access. This helps maintain security, simplifies permission management in complex environments, and supports collaborative work by allowing fine-grained control over who can read, write, or execute specific files, regardless of the underlying server structure. Ideally, institutions have mutliple Linux servers which hosts filesystems like NFS, BeeGFS, etc. where files are stored by multiple users and they need to share access of the files with other users and collaborators. The Linux ACL Management System allows IT team to set up one unified management setup (for example, a single server or multiple servers working together) that can manage file permissions on multiple file servers on demand. Linux ACL Management does this by utilizing 3 components, namely the backend, frontend, file server daemons. Each of them carry out a different responsibility and work together to make this possible. Show below is the high level architecture of the Linux ACL Management Project:","title":"The Linux ACL Management System"},{"location":"00_getting_started/project_structure/#backend-component","text":"The backend component is responsible for managing sessions and transactions, serving endpoints for frontend to control it, communicate with remote daemon components for managing file system permissions, etc. It needs to be installed on a Linux server which has access to all the file system servers in the network and have all these file systems mounted on it (for example, /mnt/nfs-mount).","title":"Backend Component"},{"location":"00_getting_started/project_structure/#terminologies","text":"","title":"Terminologies"},{"location":"00_getting_started/project_structure/#sessions","text":"Sessions are created by users who authenticate with the backend. Each session holds information related to the authenticated user and acts as a container for transactions that are scheduled and queued within it. Every session has a unique Session ID, which serves as an identifier for tracking session details, the associated user, and all related transactions. In addition to transaction data, sessions also store user-specific metadata, such as IP address and browser information. Each session is assigned an expiry timer. This timer ensures that a session automatically closes if there is no activity for a specified duration. However, the timer is paused while transactions are actively being processed, and resets once all transactions are complete. When a session expires, the user must authenticate again to create a new session. This mechanism helps frontends automatically sign users out when inactive, improving security and freeing up backend resources by cleaning up unused sessions. It ensures efficient session lifecycle management while balancing user convenience and system performance.","title":"Sessions"},{"location":"00_getting_started/project_structure/#transactions","text":"A transaction contains the ACL operation that a user wants to execute. For example, a transaction might specify that Aditya wants to grant Alice read and write permissions to /data/mri-results/mri.scan . Each transaction includes all the details required by the transaction executor to process the ACL command and return the result. Every transaction has a unique Transaction ID and is linked to the Session ID of the session that created it. Using the Transaction ID, you can trace back to the session that scheduled the transaction, and ultimately to the user who initiated it, along with all related session and user information. This structure ensures clear traceability, accountability, and accurate execution of ACL changes across the system.","title":"Transactions"},{"location":"00_getting_started/project_structure/#components-it-depends-on","text":"","title":"Components it depends on"},{"location":"00_getting_started/project_structure/#redis","text":"Redis is an open-source, in-memory data store that can be used as a database, cache, and message broker. It is known for its high performance, low latency, and simplicity, making it ideal for real-time applications. In this system, Redis acts as a mirror or intermediary for storing information about sessions and transactions. When streaming data to the frontend, the application fetches this information from Redis instead of directly querying the backend database. This approach helps reduce resource locking in the backend, where sessions and transactions are actively processed. When the frontend requests data, it needs to receive a quick response, often requiring frequent and repeated reads whenever changes occur. If these reads were handled directly by the backend, they could lock critical resources each time, potentially degrading performance especially when many users request data simultaneously. By using Redis, the backend can publish updates as soon as changes occur. The frontend can then fetch the required data from Redis as often as needed without placing additional load on the backend. This decouples read operations from the backend\u2019s transactional workload, ensuring high responsiveness for users while maintaining backend performance. Redis\u2019s efficiency in handling rapid reads and writes makes it an excellent fit for this use case.","title":"Redis"},{"location":"00_getting_started/project_structure/#postgresql","text":"PostgreSQL is a powerful, open-source, object-relational database management system known for its stability, advanced features, and standards compliance. It\u2019s widely used for applications ranging from small web apps to large, mission-critical systems that require strong data integrity and scalability. PostgreSQL in Linux ACL Management System is used as an archival database. When a session expires, it's complete information and all it's transactions information is stored into it. In case where the backend is attempted to shutdown when active sessions exist and transactions are processing, the backend first expires all the sessions and stores all the information about session and transactions into this archive. Transactions that weren't processed are marked as pending and are stored in the archive.","title":"PostgreSQL"},{"location":"00_getting_started/project_structure/#linux-file-servers","text":"","title":"Linux File Servers"},{"location":"00_getting_started/project_structure/#beegfs-file-system","text":"BeeGFS (BeeGFS stands for BeeGFS: the Berlin Exascale File System) is a high-performance, parallel file system designed for demanding environments like HPC clusters and research institutions. It allows large amounts of data to be distributed across multiple servers, providing fast access and scalability. When BeeGFS is mounted on a Linux system (typically via a client node), files and directories appear as part of the local file system hierarchy. Linux ACL changes on BeeGFS-mounted directories can be executed just like on any other local file system using standard Linux ACL tools such as setfacl and getfacl . The Linux ACL Management System interacts with these tools and apply permission changes consistently, ensuring that access rights are enforced across all nodes and users accessing the shared BeeGFS storage.","title":"BeeGFS File System"},{"location":"00_getting_started/project_structure/#nfs-file-system","text":"NFS (Network File System) is a widely used protocol that allows files and directories to be shared and accessed over a network as if they were on the local machine. Filesystems like NFS doesn't support running ACL permissions on mount points. In this case, Linux ACL Management System needs direct access to the host Linux file server where it can executed setfacl to modify ACLs. For this purpose, the backend utilizes the daemon component which executes setfacl on the demands of the backend securely.","title":"NFS File System"},{"location":"00_getting_started/project_structure/#daemons","text":"The Daemon component is used by the backend component to execute setfacl on locally on remote Linux file servers. When the backend realises that the provided file by the user belongs to a file system which demands setfacl to be executed on locally, it communicates with the daemon and gets the command executed to make the ACL change. The daemon component is divided into 2 Linux daemons: ACL API Daemon and ACL Core Daemon. Both of them are installed on the same system and they are highly dependent on each other to function as expected.","title":"Daemons"},{"location":"00_getting_started/project_structure/#acl-api-daemon","text":"The API Daemon provides a gRPC endpoint for the backend to communicate with it and provides intructions about ACL modifications. This communication is done in very secure manner. It then decodes data provided by the backend server and forwards it to ACL Core daemon via Unix sockets. The ACL API Daemon has very less privileges in the system to ensure security since it's exposed to the network.","title":"ACL API Daemon"},{"location":"00_getting_started/project_structure/#acl-core-daemon","text":"The ACL Core Daemon takes instructions from ACL API Daemon, executes setfacl on behalf of the user, and returns the response back. It is isolated from external network and communicated only with ACL API Daemon through Unix sockets.","title":"ACL Core Daemon"},{"location":"00_getting_started/project_structure/#frontend-component","text":"","title":"Frontend Component"},{"location":"01_backend_component/architecture/","text":"","title":"Architecture"},{"location":"01_backend_component/changelog/","text":"","title":"Changelog"},{"location":"01_backend_component/configuration/","text":"Note: You don't need to configure all the parameters in config.yaml . Essential parameters are required and the service will error if they are missing. All other parameters fall back to sensible defaults. Order of the configs doesn't matter. Backend Configuration Reference \u00b6 This document explains all the available configuration options for the backend service. Use this as a reference when editing your config.yaml and .env . App \u00b6 General application settings. Key Description Type name Name of the application. Default: laclm . string version Current version of the application. Default: v1.1 . string debug_mode Whether to run in debug mode (shows more logs, verbose errors). Default: false . bool session_timeout User session timeout in hours. Default: 24 . int base_path Base path for mounted storage or working directory. Required. string max_workers Maximum number of concurrent worker processes. 0 lets the scheduler decide. int Server \u00b6 Backend server deployment settings. Key Description Type host The host address the server binds to. Default: localhost . Use 0.0.0.0 to bind to all interfaces. string port The port on which the backend server runs. Default: 8080 . int Database \u00b6 Settings for databases and caching services. Key Subkey Description Type transaction_log_redis.address Redis address for transaction logging. Required. string transaction_log_redis.password Password for the Redis instance (read from env). Optional. env transaction_log_redis.db Redis database index. Default: 0 . int archival_postgres.host Hostname of the PostgreSQL server. Default: localhost . string archival_postgres.port PostgreSQL server port. Default: 5432 . int archival_postgres.user Username for PostgreSQL. Required. string archival_postgres.password Password for PostgreSQL (can be read from env). Optional but recommended. string/env archival_postgres.dbname Name of the PostgreSQL database. Required. string archival_postgres.sslmode SSL mode for PostgreSQL connection. Default: disable . string Logging \u00b6 Logging output settings for the backend service. Key Description Type file Path to the log file. Default: log/app.log . string max_size Maximum size of a single log file (in MB) before rotation. Default: 100 . int max_backups Maximum number of old log files to keep. Default: 3 . int max_age Maximum number of days to keep old log files. int compress Whether to compress rotated log files. Default: false . bool Filesystem Servers \u00b6 List of managed filesystem servers. Key Subkey Description Type path Local path or mount point for the filesystem. Required. string method Connection method: local (default) or remote . string remote.host Remote server host address. Required when method is remote . string remote.port Remote server port. Required when method is remote . int Authentication \u00b6 Settings for authentication (LDAP). Key Subkey Description Type ldap.tls Whether to use TLS for LDAP connection. Default: false . bool ldap.address LDAP server address. Required. string ldap.admin_dn LDAP admin DN (read from env). Required. env ldap.admin_password LDAP admin password (read from env). Required. env ldap.search_base LDAP search base DN. Required. string Backend Security \u00b6 Security-related settings for tokens and sessions. Key Description Type jwt_secret_token Secret token used to sign JWTs (read from env). Required. env jwt_expiry JWT expiration time in hours. Default: 24 . int Default Configuration File \u00b6 Here is a backend configuration aligned with the repository's backend/config.yaml that works in development mode. # backend environment configs app: name: laclm version: v1.1 debug_mode: true session_timeout: 1 base_path: /mnt max_workers: 5 # backend server deployment configs server: host: 0.0.0.0 port: 8080 # databases for operations database: transaction_log_redis: address: localhost:6379 password: ${LACLM_TRANS_REDIS_PASSWORD} db: 0 archival_postgres: host: localhost port: 5432 user: postgres password: ${PG_PASSWORD} dbname: postgres sslmode: disable # logging configurations logging: file: logs/app.log max_size: 100 max_backups: 5 max_age: 30 compress: true # filesystem servers that need management filesystem_servers: - path: /nfs-system method: remote remote: host: localhost port: 6593 - path: /beegfs-system method: local # authentication information authentication: ldap: tls: false address: \"ldap://localhost:389\" admin_dn: ${LACLM_LDAP_ADMIN_DN} admin_password: ${LACLM_LDAP_ADMIN_PASSWORD} search_base: \"cn=Princeton Plainsboro Hospital ,dc=myorg,dc=local\" backend_security: jwt_secret_token: ${JWT_SECRET_TOKEN} jwt_expiry: 1 Environment Variables \u00b6 Given below is the environment variables file structure which contains server specific information and must be protected. # Password for Redis Database LACLM_TRANS_REDIS_PASSWORD= # LDAP Admin DN LACLM_LDAP_ADMIN_DN= # LDAP ADMIN PASSWORD LACLM_LDAP_ADMIN_PASSWORD= # PostgreSQL password (if used in config.yaml) PG_PASSWORD= # JWT Secret Token JWT_SECRET_TOKEN= Note: The configuration mechanism is designed to make the setup replicable. You can write config.yaml once and use it to deploy multiple backends in similar environments. .env is intended to be server-specific and needs to be modified each time. This allows users to set up multiple servers with minimal config changes.","title":"Configuration"},{"location":"01_backend_component/configuration/#backend-configuration-reference","text":"This document explains all the available configuration options for the backend service. Use this as a reference when editing your config.yaml and .env .","title":"Backend Configuration Reference"},{"location":"01_backend_component/configuration/#app","text":"General application settings. Key Description Type name Name of the application. Default: laclm . string version Current version of the application. Default: v1.1 . string debug_mode Whether to run in debug mode (shows more logs, verbose errors). Default: false . bool session_timeout User session timeout in hours. Default: 24 . int base_path Base path for mounted storage or working directory. Required. string max_workers Maximum number of concurrent worker processes. 0 lets the scheduler decide. int","title":"App"},{"location":"01_backend_component/configuration/#server","text":"Backend server deployment settings. Key Description Type host The host address the server binds to. Default: localhost . Use 0.0.0.0 to bind to all interfaces. string port The port on which the backend server runs. Default: 8080 . int","title":"Server"},{"location":"01_backend_component/configuration/#database","text":"Settings for databases and caching services. Key Subkey Description Type transaction_log_redis.address Redis address for transaction logging. Required. string transaction_log_redis.password Password for the Redis instance (read from env). Optional. env transaction_log_redis.db Redis database index. Default: 0 . int archival_postgres.host Hostname of the PostgreSQL server. Default: localhost . string archival_postgres.port PostgreSQL server port. Default: 5432 . int archival_postgres.user Username for PostgreSQL. Required. string archival_postgres.password Password for PostgreSQL (can be read from env). Optional but recommended. string/env archival_postgres.dbname Name of the PostgreSQL database. Required. string archival_postgres.sslmode SSL mode for PostgreSQL connection. Default: disable . string","title":"Database"},{"location":"01_backend_component/configuration/#logging","text":"Logging output settings for the backend service. Key Description Type file Path to the log file. Default: log/app.log . string max_size Maximum size of a single log file (in MB) before rotation. Default: 100 . int max_backups Maximum number of old log files to keep. Default: 3 . int max_age Maximum number of days to keep old log files. int compress Whether to compress rotated log files. Default: false . bool","title":"Logging"},{"location":"01_backend_component/configuration/#filesystem-servers","text":"List of managed filesystem servers. Key Subkey Description Type path Local path or mount point for the filesystem. Required. string method Connection method: local (default) or remote . string remote.host Remote server host address. Required when method is remote . string remote.port Remote server port. Required when method is remote . int","title":"Filesystem Servers"},{"location":"01_backend_component/configuration/#authentication","text":"Settings for authentication (LDAP). Key Subkey Description Type ldap.tls Whether to use TLS for LDAP connection. Default: false . bool ldap.address LDAP server address. Required. string ldap.admin_dn LDAP admin DN (read from env). Required. env ldap.admin_password LDAP admin password (read from env). Required. env ldap.search_base LDAP search base DN. Required. string","title":"Authentication"},{"location":"01_backend_component/configuration/#backend-security","text":"Security-related settings for tokens and sessions. Key Description Type jwt_secret_token Secret token used to sign JWTs (read from env). Required. env jwt_expiry JWT expiration time in hours. Default: 24 . int","title":"Backend Security"},{"location":"01_backend_component/configuration/#default-configuration-file","text":"Here is a backend configuration aligned with the repository's backend/config.yaml that works in development mode. # backend environment configs app: name: laclm version: v1.1 debug_mode: true session_timeout: 1 base_path: /mnt max_workers: 5 # backend server deployment configs server: host: 0.0.0.0 port: 8080 # databases for operations database: transaction_log_redis: address: localhost:6379 password: ${LACLM_TRANS_REDIS_PASSWORD} db: 0 archival_postgres: host: localhost port: 5432 user: postgres password: ${PG_PASSWORD} dbname: postgres sslmode: disable # logging configurations logging: file: logs/app.log max_size: 100 max_backups: 5 max_age: 30 compress: true # filesystem servers that need management filesystem_servers: - path: /nfs-system method: remote remote: host: localhost port: 6593 - path: /beegfs-system method: local # authentication information authentication: ldap: tls: false address: \"ldap://localhost:389\" admin_dn: ${LACLM_LDAP_ADMIN_DN} admin_password: ${LACLM_LDAP_ADMIN_PASSWORD} search_base: \"cn=Princeton Plainsboro Hospital ,dc=myorg,dc=local\" backend_security: jwt_secret_token: ${JWT_SECRET_TOKEN} jwt_expiry: 1","title":"Default Configuration File"},{"location":"01_backend_component/configuration/#environment-variables","text":"Given below is the environment variables file structure which contains server specific information and must be protected. # Password for Redis Database LACLM_TRANS_REDIS_PASSWORD= # LDAP Admin DN LACLM_LDAP_ADMIN_DN= # LDAP ADMIN PASSWORD LACLM_LDAP_ADMIN_PASSWORD= # PostgreSQL password (if used in config.yaml) PG_PASSWORD= # JWT Secret Token JWT_SECRET_TOKEN= Note: The configuration mechanism is designed to make the setup replicable. You can write config.yaml once and use it to deploy multiple backends in similar environments. .env is intended to be server-specific and needs to be modified each time. This allows users to set up multiple servers with minimal config changes.","title":"Environment Variables"},{"location":"01_backend_component/deployment/","text":"Deployment \u00b6 Deploying the Linux ACL Management System can done via various ways. This ranges for options prioritizing security while others prefer fast pace deployment. Deploying via Source Code \u00b6 This method is the most secure and manual way of deploying Linux ACL Management System. It is recommended for institutions deploying it in an isolated environment without internet connection by building the binaries on-site where it is intended to deploy. 1. Install the Source Code Tarball \u00b6 To install the tarball, visit the official repository and follow the instructions. Copy the following commands to install it via command line. Make sure you have curl installed on the system. Linux AMD64 Architecture \u00b6 curl -L -o laclm.tar.gz https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/build/laclm-linux-amd64-source.tar.gz Linux ARM64 Architecture \u00b6 curl -L -o laclm.tar.gz https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/build/laclm-linux-arm64-source.tar.gz You may now ship the tarball to any system with no internet connection and you will be able to build from the source code there provided that you have proper build tools installed on the target machine. 2. Extract the Source Code Tarball \u00b6 Extract source code from tarball with following command. Make sure you have tar installed on the system. tar -xzf laclm.tar.gz This will create a folder in your current directory. cd into that folder. 3. Build Locally \u00b6 You can build the binary with the following command: make build-offline This will build the binary and store it at /bin . 4. Configure \u00b6 With the source code, you get config.yaml which you can configure with. For more information related to configuration, refer here . 5. Deploy \u00b6 For deploying the backend, execute the binary with config.yaml ./laclm --config <path_to_config> Note: Make sure that you have .env in the same directory where laclm is executed with config. Deploying via Prebuilt Binaries \u00b6 You can install prebuilt libraries from offical GitHub repository. Copy the following commands to install it via command line. Make sure you have curl installed on the system. 1. Download the Binary \u00b6 Linux AMD64 Architecture \u00b6 curl -L -o laclm https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/bin/laclm-linux-amd64 Linux ARM64 Architecture \u00b6 curl -L -o laclm https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/bin/laclm-linux-amd64 2. Configure \u00b6 With the source code, you get config.yaml which you can configure with. For more information related to configuration, refer here . 3. Deploy \u00b6 For deploying the backend, execute the binary with config.yaml ./laclm --config <path_to_config> Note: Make sure that you have .env in the same directory where laclm is executed with config. Deploying via Docker Ecosystem \u00b6 Warning: Docker Compose method of deployment is under development and must only be used in development mode. Most features won't work as expected. 1. Get the Source Code \u00b6 git clone https://github.com/PythonHacker24/linux-acl-management-backend 2. Build Image \u00b6 docker build -t laclm . 3. Run Docker Image \u00b6 docker run --rm laclm For development purposes, use Docker Compose to run a test LDAP server (OpenLDAP) and PHPLDAPAdmin. docker-compose up --build","title":"Deployment"},{"location":"01_backend_component/deployment/#deployment","text":"Deploying the Linux ACL Management System can done via various ways. This ranges for options prioritizing security while others prefer fast pace deployment.","title":"Deployment"},{"location":"01_backend_component/deployment/#deploying-via-source-code","text":"This method is the most secure and manual way of deploying Linux ACL Management System. It is recommended for institutions deploying it in an isolated environment without internet connection by building the binaries on-site where it is intended to deploy.","title":"Deploying via Source Code"},{"location":"01_backend_component/deployment/#1-install-the-source-code-tarball","text":"To install the tarball, visit the official repository and follow the instructions. Copy the following commands to install it via command line. Make sure you have curl installed on the system.","title":"1. Install the Source Code Tarball"},{"location":"01_backend_component/deployment/#linux-amd64-architecture","text":"curl -L -o laclm.tar.gz https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/build/laclm-linux-amd64-source.tar.gz","title":"Linux AMD64 Architecture"},{"location":"01_backend_component/deployment/#linux-arm64-architecture","text":"curl -L -o laclm.tar.gz https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/build/laclm-linux-arm64-source.tar.gz You may now ship the tarball to any system with no internet connection and you will be able to build from the source code there provided that you have proper build tools installed on the target machine.","title":"Linux ARM64 Architecture"},{"location":"01_backend_component/deployment/#2-extract-the-source-code-tarball","text":"Extract source code from tarball with following command. Make sure you have tar installed on the system. tar -xzf laclm.tar.gz This will create a folder in your current directory. cd into that folder.","title":"2. Extract the Source Code Tarball"},{"location":"01_backend_component/deployment/#3-build-locally","text":"You can build the binary with the following command: make build-offline This will build the binary and store it at /bin .","title":"3. Build Locally"},{"location":"01_backend_component/deployment/#4-configure","text":"With the source code, you get config.yaml which you can configure with. For more information related to configuration, refer here .","title":"4. Configure"},{"location":"01_backend_component/deployment/#5-deploy","text":"For deploying the backend, execute the binary with config.yaml ./laclm --config <path_to_config> Note: Make sure that you have .env in the same directory where laclm is executed with config.","title":"5. Deploy"},{"location":"01_backend_component/deployment/#deploying-via-prebuilt-binaries","text":"You can install prebuilt libraries from offical GitHub repository. Copy the following commands to install it via command line. Make sure you have curl installed on the system.","title":"Deploying via Prebuilt Binaries"},{"location":"01_backend_component/deployment/#1-download-the-binary","text":"","title":"1. Download the Binary"},{"location":"01_backend_component/deployment/#linux-amd64-architecture_1","text":"curl -L -o laclm https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/bin/laclm-linux-amd64","title":"Linux AMD64 Architecture"},{"location":"01_backend_component/deployment/#linux-arm64-architecture_1","text":"curl -L -o laclm https://github.com/PythonHacker24/linux-acl-management-backend/raw/refs/heads/development-v1/bin/laclm-linux-amd64","title":"Linux ARM64 Architecture"},{"location":"01_backend_component/deployment/#2-configure","text":"With the source code, you get config.yaml which you can configure with. For more information related to configuration, refer here .","title":"2. Configure"},{"location":"01_backend_component/deployment/#3-deploy","text":"For deploying the backend, execute the binary with config.yaml ./laclm --config <path_to_config> Note: Make sure that you have .env in the same directory where laclm is executed with config.","title":"3. Deploy"},{"location":"01_backend_component/deployment/#deploying-via-docker-ecosystem","text":"Warning: Docker Compose method of deployment is under development and must only be used in development mode. Most features won't work as expected.","title":"Deploying via Docker Ecosystem"},{"location":"01_backend_component/deployment/#1-get-the-source-code","text":"git clone https://github.com/PythonHacker24/linux-acl-management-backend","title":"1. Get the Source Code"},{"location":"01_backend_component/deployment/#2-build-image","text":"docker build -t laclm .","title":"2. Build Image"},{"location":"01_backend_component/deployment/#3-run-docker-image","text":"docker run --rm laclm For development purposes, use Docker Compose to run a test LDAP server (OpenLDAP) and PHPLDAPAdmin. docker-compose up --build","title":"3. Run Docker Image"},{"location":"01_backend_component/development/","text":"","title":"Development"},{"location":"01_backend_component/installation/","text":"Backend Quick Start \u00b6 This guide will help you get up and running quickly, whether you\u2019re developing locally or deploying in a containerized environment. Prerequisites \u00b6 Go (version 1.20+ recommended, for building with source code method) Docker and Docker Compose (for containerized setup only) PostgreSQL and Redis (Optional) Make (for using the Makefile) 1. Getting the Backend Component \u00b6 Through Prebuilt Binaries \u00b6 The prebuilt binaries are available to install on GitHub Releases for the Linux ACL Management Project. Here are one line commands to install them for all the architectures. Make sure you have curl installed. For Linux x86_64 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclm-linux-amd64 -o /usr/local/bin/aclm chmod +x /usr/local/bin/aclm For Linux ARM64 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclm-linux-amd64 -o /usr/local/bin/aclm chmod +x /usr/local/bin/aclm For Linux ARMv7 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclm-linux-amd64 -o /usr/local/bin/aclm chmod +x /usr/local/bin/aclm Through GitHub Source Code \u00b6 Visit the Official GitHub Repository for Linux ACL Management System for the complete source code. To clone the repository from GitHub, use the following command. Make sure you have git installed on your system. git clone https://github.com/PythonHacker24/linux-acl-management-backend.git 2. Configuration \u00b6 When working with the Linux ACL Management System, all you need is the backend binary, config.yaml , and .env setup with proper paramaters. With these 3 components, you are ready to deploy the backend component. The config.yaml is the heart of the Linux ACL Management System and contains all you need to setup the system. .env contains all the parameters that's meant to be server specific and kept secret (for example, database passwords, auth token parameters, etc.) More about configuration here: link to config 3. Database Setup \u00b6 Linux ACL Management System uses PostgreSQL and Redis for operations purposes. Make sure both of them are running and are configured to be used with the backend. If you\u2019re running the database locally, create the database and apply migrations: PostgreSQL \u00b6 It's recommended to follow the Official PostgreSQL docs for setting it up. It can run on a seprate server or on the same server on which the backend is running. PostgreSQL is used as an archival database where sessions and transactions are stored when they are expired or the backend system is trigged to quit it's operation in middle of operation. # Start PostgreSQL sudo service postgresql start # Create the database (example) createdb your_db_name After setting up the PostgreSQL database, you need to configure the schema for compatibility with the backend component. You just need to load up the following schema given here . You just have to copy paste the whole schema and execute it inside the database. Redis \u00b6 Linux ACL Management System uses Redis for mirroring states of sessions and transactions for streaming on web dashboard. This allows the internal process scheduler to keep working on processing them without locking the resources for streaming on web dashboards frequently. When ever changes are made in sessions and transactions inside the backend system, the data is volunterly reflected in Redis which is ready to be served on frontend and any resource demanding it. For more information on installing Redis, refer the Official Redis docs. # Start Redis sudo service redis-server start Alternatively, if you\u2019re using Docker Compose, the services will be created automatically. 4. Build (only for users with source code) \u00b6 There are currently 3 ways of installing Linux ACL Management System Backend Component. Using Go \u00b6 You can build and run the backend using Go directly, the Makefile, or Docker Compose. Building through Go can be done through the Golang compiler with one command. Incase you don't have Go installed on your system, refer to the Official Golang Docs . go build -o bin/backend ./cmd/laclm Using Makefile \u00b6 For installing via Makefile, make sure you have make installed and follow the commands listed below. The Makefile will take care of all the building procdures as per your system. Just make sure that all the required dependences are installed (like Go, protoc, etc.) For installing make , follow the Official Page for GNU's make project make build Using Docker \u00b6 For systems with docker installed and configured on them, you can use the Dockerfile for building the project image and running it. Docker Compose is meant to be a testing/development environment which loads the project image and pairs it up with OpenLDAP, PHPLdapAdmin, etc. Current docker-compose.yaml not recommended for production usage. docker-compose up --build Docker Compose will build the image, start the containers, and run the backend along with its dependencies. Note: A complete Docker-Compose file with databases and default configuration for quick deployment is under development. This will allow users to deploy the complete backend components with a few commands. 5. Useful Commands \u00b6 Build: make build Run: make run Test: make test Lint: make lint (requires golangci-lint) Clean: make clean","title":"Installation"},{"location":"01_backend_component/installation/#backend-quick-start","text":"This guide will help you get up and running quickly, whether you\u2019re developing locally or deploying in a containerized environment.","title":"Backend Quick Start"},{"location":"01_backend_component/installation/#prerequisites","text":"Go (version 1.20+ recommended, for building with source code method) Docker and Docker Compose (for containerized setup only) PostgreSQL and Redis (Optional) Make (for using the Makefile)","title":"Prerequisites"},{"location":"01_backend_component/installation/#1-getting-the-backend-component","text":"","title":"1. Getting the Backend Component"},{"location":"01_backend_component/installation/#through-prebuilt-binaries","text":"The prebuilt binaries are available to install on GitHub Releases for the Linux ACL Management Project. Here are one line commands to install them for all the architectures. Make sure you have curl installed.","title":"Through Prebuilt Binaries"},{"location":"01_backend_component/installation/#for-linux-x86_64","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclm-linux-amd64 -o /usr/local/bin/aclm chmod +x /usr/local/bin/aclm","title":"For Linux x86_64"},{"location":"01_backend_component/installation/#for-linux-arm64","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclm-linux-amd64 -o /usr/local/bin/aclm chmod +x /usr/local/bin/aclm","title":"For Linux ARM64"},{"location":"01_backend_component/installation/#for-linux-armv7","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclm-linux-amd64 -o /usr/local/bin/aclm chmod +x /usr/local/bin/aclm","title":"For Linux ARMv7"},{"location":"01_backend_component/installation/#through-github-source-code","text":"Visit the Official GitHub Repository for Linux ACL Management System for the complete source code. To clone the repository from GitHub, use the following command. Make sure you have git installed on your system. git clone https://github.com/PythonHacker24/linux-acl-management-backend.git","title":"Through GitHub Source Code"},{"location":"01_backend_component/installation/#2-configuration","text":"When working with the Linux ACL Management System, all you need is the backend binary, config.yaml , and .env setup with proper paramaters. With these 3 components, you are ready to deploy the backend component. The config.yaml is the heart of the Linux ACL Management System and contains all you need to setup the system. .env contains all the parameters that's meant to be server specific and kept secret (for example, database passwords, auth token parameters, etc.) More about configuration here: link to config","title":"2. Configuration"},{"location":"01_backend_component/installation/#3-database-setup","text":"Linux ACL Management System uses PostgreSQL and Redis for operations purposes. Make sure both of them are running and are configured to be used with the backend. If you\u2019re running the database locally, create the database and apply migrations:","title":"3. Database Setup"},{"location":"01_backend_component/installation/#postgresql","text":"It's recommended to follow the Official PostgreSQL docs for setting it up. It can run on a seprate server or on the same server on which the backend is running. PostgreSQL is used as an archival database where sessions and transactions are stored when they are expired or the backend system is trigged to quit it's operation in middle of operation. # Start PostgreSQL sudo service postgresql start # Create the database (example) createdb your_db_name After setting up the PostgreSQL database, you need to configure the schema for compatibility with the backend component. You just need to load up the following schema given here . You just have to copy paste the whole schema and execute it inside the database.","title":"PostgreSQL"},{"location":"01_backend_component/installation/#redis","text":"Linux ACL Management System uses Redis for mirroring states of sessions and transactions for streaming on web dashboard. This allows the internal process scheduler to keep working on processing them without locking the resources for streaming on web dashboards frequently. When ever changes are made in sessions and transactions inside the backend system, the data is volunterly reflected in Redis which is ready to be served on frontend and any resource demanding it. For more information on installing Redis, refer the Official Redis docs. # Start Redis sudo service redis-server start Alternatively, if you\u2019re using Docker Compose, the services will be created automatically.","title":"Redis"},{"location":"01_backend_component/installation/#4-build-only-for-users-with-source-code","text":"There are currently 3 ways of installing Linux ACL Management System Backend Component.","title":"4. Build (only for users with source code)"},{"location":"01_backend_component/installation/#using-go","text":"You can build and run the backend using Go directly, the Makefile, or Docker Compose. Building through Go can be done through the Golang compiler with one command. Incase you don't have Go installed on your system, refer to the Official Golang Docs . go build -o bin/backend ./cmd/laclm","title":"Using Go"},{"location":"01_backend_component/installation/#using-makefile","text":"For installing via Makefile, make sure you have make installed and follow the commands listed below. The Makefile will take care of all the building procdures as per your system. Just make sure that all the required dependences are installed (like Go, protoc, etc.) For installing make , follow the Official Page for GNU's make project make build","title":"Using Makefile"},{"location":"01_backend_component/installation/#using-docker","text":"For systems with docker installed and configured on them, you can use the Dockerfile for building the project image and running it. Docker Compose is meant to be a testing/development environment which loads the project image and pairs it up with OpenLDAP, PHPLdapAdmin, etc. Current docker-compose.yaml not recommended for production usage. docker-compose up --build Docker Compose will build the image, start the containers, and run the backend along with its dependencies. Note: A complete Docker-Compose file with databases and default configuration for quick deployment is under development. This will allow users to deploy the complete backend components with a few commands.","title":"Using Docker"},{"location":"01_backend_component/installation/#5-useful-commands","text":"Build: make build Run: make run Test: make test Lint: make lint (requires golangci-lint) Clean: make clean","title":"5. Useful Commands"},{"location":"01_backend_component/quick_start/","text":"Introduction \u00b6 The backend component serves as the central component for Linux ACL Management System. It manages the creation of all the sessions, scheduling transactions, executing them in a systematic manner while serving the frontend with data and endpoints to control the system. It has access to all the mounts that need ACL management and connections to daemon where ACL changes are required to be executed (in case where ACL commands cannot be executed on the mount). Get the source code on the Official GitHub Repository .","title":"Quick Start"},{"location":"01_backend_component/quick_start/#introduction","text":"The backend component serves as the central component for Linux ACL Management System. It manages the creation of all the sessions, scheduling transactions, executing them in a systematic manner while serving the frontend with data and endpoints to control the system. It has access to all the mounts that need ACL management and connections to daemon where ACL changes are required to be executed (in case where ACL commands cannot be executed on the mount). Get the source code on the Official GitHub Repository .","title":"Introduction"},{"location":"01_backend_component/troubleshooting/","text":"Info: Troubleshooting would be written once enough issues occur while using the system and solutions are created to tackle them.","title":"Troubleshooting"},{"location":"02_daemon_component/architecture/","text":"Architecture \u00b6 When we talk about the daemon component, we consider 2 daemons working together: aclapi and aclcore . A top level architecture of daemon component has been visualized below. The aclapi exposes a gRPC handler which the backend component uses to communicate with it. The data that recieved through this is deserialized and sent to aclcore via Unix sockets. aclcore takes the instruction and executes it on the system via setfacl . ACL API gRPC Schema \u00b6 You can find the protobuf files for aclapi in the source code here . 1. ACL gRPC Service \u00b6 This section describes the ACLService defined in acl.proto for managing Linux Access Control Lists (ACLs) via gRPC. The ACLService provides an RPC method to apply ACL entries to files or directories. RPC Method for ACLService \u00b6 rpc ApplyACLEntry (ApplyACLRequest) returns (ApplyACLResponse); Description \u00b6 Applies an ACL entry (add, modify, or remove) to a given file or directory. Messages \u00b6 ACLEntry represents a single ACL Entry: Field Type Description entity_type string Type of the entity: \"user\" , \"group\" , \"mask\" , or \"other\" . entity string Name of the user or group. Can be empty for \"other\" or \"mask\" . permissions string Permissions in symbolic format, e.g., \"rw-\" . action string Operation to perform: \"add\" , \"modify\" , or \"remove\" . is_default bool Whether this entry is for the default ACL ( true or false ). ApplyACLRequest \u00b6 Request message for ApplyACLEntry . Field Type Description transactionID string Unique ID for tracking this request. target_path string Path to the file or directory to apply the ACL to. entry ACLEntry The ACL entry to apply. ApplyACLResponse \u00b6 Response message for ApplyACLEntry . Field Type Description success bool Indicates whether the operation was successful. message string Additional information or error message. Example Usage \u00b6 Below is an example of how a client might call the ApplyACLEntry RPC: { \"transactionID\": \"abc123\", \"target_path\": \"/home/alice/docs\", \"entry\": { \"entity_type\": \"user\", \"entity\": \"alice\", \"permissions\": \"rw-\", \"action\": \"add\", \"is_default\": false } } The response might look like: { \"success\": true, \"message\": \"ACL entry added successfully.\" } 2. Ping gRPC Service \u00b6 The PingService provides a simple RPC to check if the server is reachable. RPC Method for PingService \u00b6 rpc Ping (PingRequest) returns (PingResponse); Description \u00b6 Sends a simple ping request to the server and expects a response message. Messages \u00b6 Ping Request Field Type Description (empty) (empty) This message has no fields. Ping Response Field Type Description message string The server\u2019s response message, e.g., \"pong\" . Example Usage \u00b6 Request {} Response might look like { \"message\": \"pong\" }","title":"Architecture"},{"location":"02_daemon_component/architecture/#architecture","text":"When we talk about the daemon component, we consider 2 daemons working together: aclapi and aclcore . A top level architecture of daemon component has been visualized below. The aclapi exposes a gRPC handler which the backend component uses to communicate with it. The data that recieved through this is deserialized and sent to aclcore via Unix sockets. aclcore takes the instruction and executes it on the system via setfacl .","title":"Architecture"},{"location":"02_daemon_component/architecture/#acl-api-grpc-schema","text":"You can find the protobuf files for aclapi in the source code here .","title":"ACL API gRPC Schema"},{"location":"02_daemon_component/architecture/#1-acl-grpc-service","text":"This section describes the ACLService defined in acl.proto for managing Linux Access Control Lists (ACLs) via gRPC. The ACLService provides an RPC method to apply ACL entries to files or directories.","title":"1. ACL gRPC Service"},{"location":"02_daemon_component/architecture/#rpc-method-for-aclservice","text":"rpc ApplyACLEntry (ApplyACLRequest) returns (ApplyACLResponse);","title":"RPC Method for ACLService"},{"location":"02_daemon_component/architecture/#description","text":"Applies an ACL entry (add, modify, or remove) to a given file or directory.","title":"Description"},{"location":"02_daemon_component/architecture/#messages","text":"ACLEntry represents a single ACL Entry: Field Type Description entity_type string Type of the entity: \"user\" , \"group\" , \"mask\" , or \"other\" . entity string Name of the user or group. Can be empty for \"other\" or \"mask\" . permissions string Permissions in symbolic format, e.g., \"rw-\" . action string Operation to perform: \"add\" , \"modify\" , or \"remove\" . is_default bool Whether this entry is for the default ACL ( true or false ).","title":"Messages"},{"location":"02_daemon_component/architecture/#applyaclrequest","text":"Request message for ApplyACLEntry . Field Type Description transactionID string Unique ID for tracking this request. target_path string Path to the file or directory to apply the ACL to. entry ACLEntry The ACL entry to apply.","title":"ApplyACLRequest"},{"location":"02_daemon_component/architecture/#applyaclresponse","text":"Response message for ApplyACLEntry . Field Type Description success bool Indicates whether the operation was successful. message string Additional information or error message.","title":"ApplyACLResponse"},{"location":"02_daemon_component/architecture/#example-usage","text":"Below is an example of how a client might call the ApplyACLEntry RPC: { \"transactionID\": \"abc123\", \"target_path\": \"/home/alice/docs\", \"entry\": { \"entity_type\": \"user\", \"entity\": \"alice\", \"permissions\": \"rw-\", \"action\": \"add\", \"is_default\": false } } The response might look like: { \"success\": true, \"message\": \"ACL entry added successfully.\" }","title":"Example Usage"},{"location":"02_daemon_component/architecture/#2-ping-grpc-service","text":"The PingService provides a simple RPC to check if the server is reachable.","title":"2. Ping gRPC Service"},{"location":"02_daemon_component/architecture/#rpc-method-for-pingservice","text":"rpc Ping (PingRequest) returns (PingResponse);","title":"RPC Method for PingService"},{"location":"02_daemon_component/architecture/#description_1","text":"Sends a simple ping request to the server and expects a response message.","title":"Description"},{"location":"02_daemon_component/architecture/#messages_1","text":"Ping Request Field Type Description (empty) (empty) This message has no fields. Ping Response Field Type Description message string The server\u2019s response message, e.g., \"pong\" .","title":"Messages"},{"location":"02_daemon_component/architecture/#example-usage_1","text":"Request {} Response might look like { \"message\": \"pong\" }","title":"Example Usage"},{"location":"02_daemon_component/changelog/","text":"","title":"Changelog"},{"location":"02_daemon_component/configuration/","text":"ACL API \u00b6 daemon \u00b6 General settings for the ACLAPI Daemon process. Key Description Type debug_mode Enable debug mode ( true for development, false for production). bool logs \u00b6 Logging options for the daemon. Key Description Type file Path to the log file. string max_size Maximum size (in MB) of a single log file before rotation. int max_backups Maximum number of rotated log files to keep. int max_age Maximum number of days to retain old log files. int compress Whether to compress rotated log files. bool server \u00b6 Server settings for the gRPC API. Key Description Type host Host address to bind the gRPC server. string grpc_port Port on which the gRPC server listens. int tls_enabled Enable TLS for the gRPC server ( true recommended for production). bool tls_cert_file Path to the TLS certificate file (required if tls_enabled is true ). string tls_key_file Path to the TLS key file (required if tls_enabled is true ). string tls_ca_cert_file Path to the CA certificate file (required if tls_enabled is true ). string Config File Template \u00b6 # ACLAPI Daemon Configuration # Daemon section daemon: # Enable debug mode (true for development, false for production) debug_mode: # Logging section logs: # Log file path (default: /var/log/aclapi/aclapi.log) file: # Maximum size of a log file in MB before rotation (default: 100) max_size: # Maximum number of backup log files to keep (default: 3) max_backups: # Maximum age in days to retain old log files (default: 0, unlimited) max_age: # Compress rotated log files (default: false) compress: # Server section server: # Host address to bind the gRPC server (default: 0.0.0.0) host: # gRPC port to listen on (default: 6593) grpc_port: # Enable TLS for gRPC server (recommended: true in production) tls_enabled: # Path to TLS certificate file (required if tls_enabled is true) tls_cert_file: # Path to TLS key file (required if tls_enabled is true) tls_key_file: # Path to CA certificate file (required if tls_enabled is true) tls_ca_cert_file: ACL Core \u00b6 Daemon \u00b6 General settings for the ACLCORE Daemon process. Key Description Type debug_mode Enable debug mode ( true for development, false for production). bool socket_path Path to the UNIX socket used by the daemon. string max_conn_pool Maximum number of allowed pooled connections. int Logs \u00b6 Logging options for the daemon. Key Description Type file Path to the log file. string max_size Maximum size (in MB) of a single log file before rotation. int max_backups Maximum number of rotated log files to keep. int max_age Maximum number of days to retain old log files. int compress Whether to compress rotated log files. bool Config File Template \u00b6 # ACLCORE Daemon Configuration # Daemon section daemon: # Enable debug mode (true for development, false for production) debug_mode: socket_path: max_conn_pool: # Logging section logs: # Log file path (default: /var/log/aclapi/aclapi.log) file: # Maximum size of a log file in MB before rotation (default: 100) max_size: # Maximum number of backup log files to keep (default: 3) max_backups: # Maximum age in days to retain old log files (default: 0, unlimited) max_age: # Compress rotated log files (default: false) compress:","title":"Configuration"},{"location":"02_daemon_component/configuration/#acl-api","text":"","title":"ACL API"},{"location":"02_daemon_component/configuration/#daemon","text":"General settings for the ACLAPI Daemon process. Key Description Type debug_mode Enable debug mode ( true for development, false for production). bool","title":"daemon"},{"location":"02_daemon_component/configuration/#logs","text":"Logging options for the daemon. Key Description Type file Path to the log file. string max_size Maximum size (in MB) of a single log file before rotation. int max_backups Maximum number of rotated log files to keep. int max_age Maximum number of days to retain old log files. int compress Whether to compress rotated log files. bool","title":"logs"},{"location":"02_daemon_component/configuration/#server","text":"Server settings for the gRPC API. Key Description Type host Host address to bind the gRPC server. string grpc_port Port on which the gRPC server listens. int tls_enabled Enable TLS for the gRPC server ( true recommended for production). bool tls_cert_file Path to the TLS certificate file (required if tls_enabled is true ). string tls_key_file Path to the TLS key file (required if tls_enabled is true ). string tls_ca_cert_file Path to the CA certificate file (required if tls_enabled is true ). string","title":"server"},{"location":"02_daemon_component/configuration/#config-file-template","text":"# ACLAPI Daemon Configuration # Daemon section daemon: # Enable debug mode (true for development, false for production) debug_mode: # Logging section logs: # Log file path (default: /var/log/aclapi/aclapi.log) file: # Maximum size of a log file in MB before rotation (default: 100) max_size: # Maximum number of backup log files to keep (default: 3) max_backups: # Maximum age in days to retain old log files (default: 0, unlimited) max_age: # Compress rotated log files (default: false) compress: # Server section server: # Host address to bind the gRPC server (default: 0.0.0.0) host: # gRPC port to listen on (default: 6593) grpc_port: # Enable TLS for gRPC server (recommended: true in production) tls_enabled: # Path to TLS certificate file (required if tls_enabled is true) tls_cert_file: # Path to TLS key file (required if tls_enabled is true) tls_key_file: # Path to CA certificate file (required if tls_enabled is true) tls_ca_cert_file:","title":"Config File Template"},{"location":"02_daemon_component/configuration/#acl-core","text":"","title":"ACL Core"},{"location":"02_daemon_component/configuration/#daemon_1","text":"General settings for the ACLCORE Daemon process. Key Description Type debug_mode Enable debug mode ( true for development, false for production). bool socket_path Path to the UNIX socket used by the daemon. string max_conn_pool Maximum number of allowed pooled connections. int","title":"Daemon"},{"location":"02_daemon_component/configuration/#logs_1","text":"Logging options for the daemon. Key Description Type file Path to the log file. string max_size Maximum size (in MB) of a single log file before rotation. int max_backups Maximum number of rotated log files to keep. int max_age Maximum number of days to retain old log files. int compress Whether to compress rotated log files. bool","title":"Logs"},{"location":"02_daemon_component/configuration/#config-file-template_1","text":"# ACLCORE Daemon Configuration # Daemon section daemon: # Enable debug mode (true for development, false for production) debug_mode: socket_path: max_conn_pool: # Logging section logs: # Log file path (default: /var/log/aclapi/aclapi.log) file: # Maximum size of a log file in MB before rotation (default: 100) max_size: # Maximum number of backup log files to keep (default: 3) max_backups: # Maximum age in days to retain old log files (default: 0, unlimited) max_age: # Compress rotated log files (default: false) compress:","title":"Config File Template"},{"location":"02_daemon_component/deployment/","text":"Deployment \u00b6 Deploying the Linux ACL Management System can done via various ways. This ranges for options prioritizing security while others prefer fast pace deployment. Since deploying the Linux ACL Daemons Components require aclapi and aclcore daemons, it is recommended that you install them together. Deploying via Source Code \u00b6 This method is the most secure and manual way of deploying Linux ACL Management System. It is recommended for institutions deploying it in an isolated environment without internet connection by building the binaries on-site where it is intended to deploy. 1. Install the Source Code Tarball \u00b6 To install the tarball, visit the official repository and follow the instructions. Copy the following commands to install it via command line. Make sure you have curl installed on the system. Linux AMD64 Architecture \u00b6 For ACl API Daemon: curl -L -o aclapi.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/development-v1/build/aclapi-linux-amd64-source.tar.gz For ACL Core Daemon: curl -L -o aclcore.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/development-v1/build/aclcore-linux-amd64-source.tar.gz Linux ARM64 Architecture\u00b6 \u00b6 For ACl API Daemon: curl -L -o aclapi.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/development-v1/build/aclapi-linux-arm64-source.tar.gz For ACL Core Daemon: curl -L -o aclcore.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/development-v1/build/aclcore-linux-arm64-source.tar.gz You may now ship the tarball to any system with no internet connection and you will be able to build from the source code there provided that you have proper build tools installed on the target machine. 2. Extract the Source Code Tarball \u00b6 Extract source code from tarball with following command. Make sure you have tar installed on the system. For ACL API Daemon: tar -xzf aclapi.tar.gz For ACL Core Daemon: tar -xzf aclcore.tar.gz This will create a 2 folders in your current directory. You need to build them in their own directory. 3. Build Locally \u00b6 You can build the binary with the following command: For ACL API Daemon: cd aclapi/ make build-offline For ACL Core Daemon: cd aclcore/ make build-offline This will build the binary for the source code and store it at /bin . You should see aclapi/bin/aclapi and aclcore/bin/aclcore binaires respectively. After building the binaries, move them to /usr/local/bin/ . Move ACL API to /usr/local/bin/ sudo cp ./bin/aclapi /usr/local/bin/ Move ACL Core to /usr/local/bin/ sudo cp ./bin/aclcore /usr/local/bin/ /usr/local/bin/ is the location where our systemd service will load the binaries from to create daemons that will run in the background. After completing this steps, you can jump to Complete Daemon Component Setup for steps. Deploying via Prebuilt Binaries \u00b6 You can install prebuilt libraries from offical GitHub repository. Copy the following commands to install it via command line. Make sure you have curl installed on the system. Linux AMD64 Architecture \u00b6 ACL API Daemon: curl -L -o aclapi https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/main/bin/aclapi-linux-amd64 ACL Core Daemon: curl -L -o aclcore https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/main/bin/aclcore-linux-amd64 Linux ARM64 Architecture\u00b6 \u00b6 ACL API Daemon: curl -L -o aclapi https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/main/bin/aclapi-linux-arm64 ACL Core Daemon: curl -L -o aclcore https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/main/bin/aclcore-linux-arm64 After completing this steps, you can jump to Complete Daemon Component Setup for steps. Complete Daemon Component Setup \u00b6 At this point, you have a binary built/installed in your preferred way and we are ready to deploy it on the file server. 1. Configure \u00b6 With the source code of ACL API and ACL Core, you get aclapi.yaml and aclcore.yaml which you can configure with. For more information related to configuration, refer here . After you configure the binaries, move them to /etc/laclm/ from which the systemd will load the configuration from and provide it to the binary. First, create a directory called /etc/laclm/ : mkdir /etc/laclm/ Move the configuration files to /etc/laclm/ cp aclapi/aclapi.yaml /etc/laclm/ cp aclcore/aclcore.yaml /etc/laclm/ 2. Change Ownership and Access Permissions for ACL Core \u00b6 Since aclcore is going to run as root, you need to change the ownership of it to root and provide 775 permissions to it. sudo chown root:root /usr/local/bin/aclcore sudo chmod 755 /usr/local/bin/aclcore 3. Create a group called laclm \u00b6 Create a group called laclm . sudo groupadd laclm 4. Add root user to laclm group \u00b6 sudo usermod -a -G laclm root 5. Create a user called aclapi with no home, least privileges, and added into laclm group. \u00b6 sudo useradd --system --no-create-home --shell /usr/sbin/nologin --groups laclm aclapi 6. Create service for ACL API Daemon \u00b6 a. Create the systemd service file \u00b6 sudo touch /etc/systemd/system/aclapi.service b. Copy this into aclapi.service \u00b6 [Unit] Description=ACL API Daemon After=network.target Requires=aclcore.service [Service] Type=simple ExecStart=/usr/local/bin/aclapi --config /etc/laclm/aclapi.yaml User=aclapi Group=laclm NoNewPrivileges=yes ProtectSystem=strict ProtectHome=yes PrivateTmp=yes Restart=on-failure [Install] WantedBy=multi-user.target 7. Create service for ACL Core Daemon \u00b6 a. Create the systemd service file \u00b6 sudo touch /etc/systemd/system/aclcore.service b. Copy this into aclcore.service \u00b6 [Unit] Description=ACL Core Daemon After=network.target [Service] Type=simple ExecStart=/usr/local/bin/aclcore --config /etc/laclm/aclcore.yaml User=root Group=laclm PrivateTmp=yes ProtectSystem=full ProtectHome=yes NoNewPrivileges=yes PrivateNetwork=yes Restart=on-failure [Install] WantedBy=multi-user.target 8. Reload SystemD daemons \u00b6 sudo systemctl daemon-reload 9. Enable aclcore service (optional: daemon will auto start when system is restarted) \u00b6 sudo systemctl enable aclcore.service 10. Start aclcore service \u00b6 sudo systemctl start aclcore.service 11. Check aclcore status \u00b6 sudo systemctl status aclcore.service 12. Enable aclapi service (optional: daemon will auto start when system is restarted) \u00b6 sudo systemctl enable aclapi.service 13. Start aclapi service \u00b6 sudo systemctl start aclapi.service 14. Check aclapi status \u00b6 sudo systemctl status aclapi.service Testing Deployment \u00b6 To test if the daemons are working properly, you can do manual tests before proceeding. The backend, however, attempts to connect all the daemons when it begins, so any daemon deployment issues can be caught while deploying the backend. However, it's better to test them beforehand. The ACL API Daemon exposes gRPC handler which you can interact with to test. You can use gRPC UI to connect to the ACL API Daemon and test it. Find gRPC UI here . Install and configure it before proceeding. Run the following command to connect to the ACL API Daemon's gRPC Handler: grpcui -plaintext <hostname>:<port> hostname is the IP of you machine which you testing device has access to and port is the network port you decided to use for the gRPC handler which is specified in aclapi.yaml (default is 6593 ). You will get a localhost link on the system you are testing. Navigate to the URL and select PingService . If you are able to ping, then ACL API Daemon is working fine. To test ACL Core Daemon, you need to select ACLEntry.Service and you can try to change ACL value of a file by filling the parameters. The schema can be found here .","title":"Deployment"},{"location":"02_daemon_component/deployment/#deployment","text":"Deploying the Linux ACL Management System can done via various ways. This ranges for options prioritizing security while others prefer fast pace deployment. Since deploying the Linux ACL Daemons Components require aclapi and aclcore daemons, it is recommended that you install them together.","title":"Deployment"},{"location":"02_daemon_component/deployment/#deploying-via-source-code","text":"This method is the most secure and manual way of deploying Linux ACL Management System. It is recommended for institutions deploying it in an isolated environment without internet connection by building the binaries on-site where it is intended to deploy.","title":"Deploying via Source Code"},{"location":"02_daemon_component/deployment/#1-install-the-source-code-tarball","text":"To install the tarball, visit the official repository and follow the instructions. Copy the following commands to install it via command line. Make sure you have curl installed on the system.","title":"1. Install the Source Code Tarball"},{"location":"02_daemon_component/deployment/#linux-amd64-architecture","text":"For ACl API Daemon: curl -L -o aclapi.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/development-v1/build/aclapi-linux-amd64-source.tar.gz For ACL Core Daemon: curl -L -o aclcore.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/development-v1/build/aclcore-linux-amd64-source.tar.gz","title":"Linux AMD64 Architecture"},{"location":"02_daemon_component/deployment/#linux-arm64-architecture","text":"For ACl API Daemon: curl -L -o aclapi.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/development-v1/build/aclapi-linux-arm64-source.tar.gz For ACL Core Daemon: curl -L -o aclcore.tar.gz https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/development-v1/build/aclcore-linux-arm64-source.tar.gz You may now ship the tarball to any system with no internet connection and you will be able to build from the source code there provided that you have proper build tools installed on the target machine.","title":"Linux ARM64 Architecture\u00b6"},{"location":"02_daemon_component/deployment/#2-extract-the-source-code-tarball","text":"Extract source code from tarball with following command. Make sure you have tar installed on the system. For ACL API Daemon: tar -xzf aclapi.tar.gz For ACL Core Daemon: tar -xzf aclcore.tar.gz This will create a 2 folders in your current directory. You need to build them in their own directory.","title":"2. Extract the Source Code Tarball"},{"location":"02_daemon_component/deployment/#3-build-locally","text":"You can build the binary with the following command: For ACL API Daemon: cd aclapi/ make build-offline For ACL Core Daemon: cd aclcore/ make build-offline This will build the binary for the source code and store it at /bin . You should see aclapi/bin/aclapi and aclcore/bin/aclcore binaires respectively. After building the binaries, move them to /usr/local/bin/ . Move ACL API to /usr/local/bin/ sudo cp ./bin/aclapi /usr/local/bin/ Move ACL Core to /usr/local/bin/ sudo cp ./bin/aclcore /usr/local/bin/ /usr/local/bin/ is the location where our systemd service will load the binaries from to create daemons that will run in the background. After completing this steps, you can jump to Complete Daemon Component Setup for steps.","title":"3. Build Locally"},{"location":"02_daemon_component/deployment/#deploying-via-prebuilt-binaries","text":"You can install prebuilt libraries from offical GitHub repository. Copy the following commands to install it via command line. Make sure you have curl installed on the system.","title":"Deploying via Prebuilt Binaries"},{"location":"02_daemon_component/deployment/#linux-amd64-architecture_1","text":"ACL API Daemon: curl -L -o aclapi https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/main/bin/aclapi-linux-amd64 ACL Core Daemon: curl -L -o aclcore https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/main/bin/aclcore-linux-amd64","title":"Linux AMD64 Architecture"},{"location":"02_daemon_component/deployment/#linux-arm64-architecture_1","text":"ACL API Daemon: curl -L -o aclapi https://github.com/PythonHacker24/linux-acl-management-aclapi/raw/refs/heads/main/bin/aclapi-linux-arm64 ACL Core Daemon: curl -L -o aclcore https://github.com/PythonHacker24/linux-acl-management-aclcore/raw/refs/heads/main/bin/aclcore-linux-arm64 After completing this steps, you can jump to Complete Daemon Component Setup for steps.","title":"Linux ARM64 Architecture\u00b6"},{"location":"02_daemon_component/deployment/#complete-daemon-component-setup","text":"At this point, you have a binary built/installed in your preferred way and we are ready to deploy it on the file server.","title":"Complete Daemon Component Setup"},{"location":"02_daemon_component/deployment/#1-configure","text":"With the source code of ACL API and ACL Core, you get aclapi.yaml and aclcore.yaml which you can configure with. For more information related to configuration, refer here . After you configure the binaries, move them to /etc/laclm/ from which the systemd will load the configuration from and provide it to the binary. First, create a directory called /etc/laclm/ : mkdir /etc/laclm/ Move the configuration files to /etc/laclm/ cp aclapi/aclapi.yaml /etc/laclm/ cp aclcore/aclcore.yaml /etc/laclm/","title":"1. Configure"},{"location":"02_daemon_component/deployment/#2-change-ownership-and-access-permissions-for-acl-core","text":"Since aclcore is going to run as root, you need to change the ownership of it to root and provide 775 permissions to it. sudo chown root:root /usr/local/bin/aclcore sudo chmod 755 /usr/local/bin/aclcore","title":"2. Change Ownership and Access Permissions for ACL Core"},{"location":"02_daemon_component/deployment/#3-create-a-group-called-laclm","text":"Create a group called laclm . sudo groupadd laclm","title":"3. Create a group called laclm"},{"location":"02_daemon_component/deployment/#4-add-root-user-to-laclm-group","text":"sudo usermod -a -G laclm root","title":"4. Add root user to laclm group"},{"location":"02_daemon_component/deployment/#5-create-a-user-called-aclapi-with-no-home-least-privileges-and-added-into-laclm-group","text":"sudo useradd --system --no-create-home --shell /usr/sbin/nologin --groups laclm aclapi","title":"5. Create a user called aclapi with no home, least privileges, and added into laclm group."},{"location":"02_daemon_component/deployment/#6-create-service-for-acl-api-daemon","text":"","title":"6. Create service for ACL API Daemon"},{"location":"02_daemon_component/deployment/#a-create-the-systemd-service-file","text":"sudo touch /etc/systemd/system/aclapi.service","title":"a. Create the systemd service file"},{"location":"02_daemon_component/deployment/#b-copy-this-into-aclapiservice","text":"[Unit] Description=ACL API Daemon After=network.target Requires=aclcore.service [Service] Type=simple ExecStart=/usr/local/bin/aclapi --config /etc/laclm/aclapi.yaml User=aclapi Group=laclm NoNewPrivileges=yes ProtectSystem=strict ProtectHome=yes PrivateTmp=yes Restart=on-failure [Install] WantedBy=multi-user.target","title":"b. Copy this into aclapi.service"},{"location":"02_daemon_component/deployment/#7-create-service-for-acl-core-daemon","text":"","title":"7. Create service for ACL Core Daemon"},{"location":"02_daemon_component/deployment/#a-create-the-systemd-service-file_1","text":"sudo touch /etc/systemd/system/aclcore.service","title":"a. Create the systemd service file"},{"location":"02_daemon_component/deployment/#b-copy-this-into-aclcoreservice","text":"[Unit] Description=ACL Core Daemon After=network.target [Service] Type=simple ExecStart=/usr/local/bin/aclcore --config /etc/laclm/aclcore.yaml User=root Group=laclm PrivateTmp=yes ProtectSystem=full ProtectHome=yes NoNewPrivileges=yes PrivateNetwork=yes Restart=on-failure [Install] WantedBy=multi-user.target","title":"b. Copy this into aclcore.service"},{"location":"02_daemon_component/deployment/#8-reload-systemd-daemons","text":"sudo systemctl daemon-reload","title":"8. Reload SystemD daemons"},{"location":"02_daemon_component/deployment/#9-enable-aclcore-service-optional-daemon-will-auto-start-when-system-is-restarted","text":"sudo systemctl enable aclcore.service","title":"9. Enable aclcore service (optional: daemon will auto start when system is restarted)"},{"location":"02_daemon_component/deployment/#10-start-aclcore-service","text":"sudo systemctl start aclcore.service","title":"10. Start aclcore service"},{"location":"02_daemon_component/deployment/#11-check-aclcore-status","text":"sudo systemctl status aclcore.service","title":"11. Check aclcore status"},{"location":"02_daemon_component/deployment/#12-enable-aclapi-service-optional-daemon-will-auto-start-when-system-is-restarted","text":"sudo systemctl enable aclapi.service","title":"12. Enable aclapi service (optional: daemon will auto start when system is restarted)"},{"location":"02_daemon_component/deployment/#13-start-aclapi-service","text":"sudo systemctl start aclapi.service","title":"13. Start aclapi service"},{"location":"02_daemon_component/deployment/#14-check-aclapi-status","text":"sudo systemctl status aclapi.service","title":"14. Check aclapi status"},{"location":"02_daemon_component/deployment/#testing-deployment","text":"To test if the daemons are working properly, you can do manual tests before proceeding. The backend, however, attempts to connect all the daemons when it begins, so any daemon deployment issues can be caught while deploying the backend. However, it's better to test them beforehand. The ACL API Daemon exposes gRPC handler which you can interact with to test. You can use gRPC UI to connect to the ACL API Daemon and test it. Find gRPC UI here . Install and configure it before proceeding. Run the following command to connect to the ACL API Daemon's gRPC Handler: grpcui -plaintext <hostname>:<port> hostname is the IP of you machine which you testing device has access to and port is the network port you decided to use for the gRPC handler which is specified in aclapi.yaml (default is 6593 ). You will get a localhost link on the system you are testing. Navigate to the URL and select PingService . If you are able to ping, then ACL API Daemon is working fine. To test ACL Core Daemon, you need to select ACLEntry.Service and you can try to change ACL value of a file by filling the parameters. The schema can be found here .","title":"Testing Deployment"},{"location":"02_daemon_component/development/","text":"","title":"Development"},{"location":"02_daemon_component/installation/","text":"ACL API Daemon \u00b6 1. Getting the ACL API Daemon \u00b6 Through Prebuilt Binaries \u00b6 The prebuilt binaries are available to install on GitHub Releases for the Linux ACL Management Project. Here are one line commands to install them for all the architectures. Make sure you have curl installed. For Linux x86_64 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclapi-linux-amd64 -o /usr/local/bin/aclapi chmod +x /usr/local/bin/aclapi For Linux ARM64 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclapi-linux-amd64 -o /usr/local/bin/aclapi chmod +x /usr/local/bin/aclapi Through GitHub Source Code \u00b6 Visit the Official GitHub Repository for Linux ACL Management System for the complete source code. To clone the repository from GitHub, use the following command. Make sure you have git installed on your system. git clone https://github.com/PythonHacker24/linux-acl-management-aclapi 2. Configuration \u00b6 When working with the Linux ACL Management System's ACL API Daemon Component, all you need is the aclapi binary, aclapi.yaml with proper paramaters. The aclapi.yaml is the heart of the Linux ACL Management System ACL API Daemon and contains all you need to setup the system. More about configuration here: link to config 3. Build \u00b6 There are currently 2 ways of building Linux ACL Management System ACL API Daemon Component. You can build and run the aclapi using Go directly or the Makefile. Using Go \u00b6 Building through Go can be done through the Golang compiler with one command. Incase you don't have Go installed on your system, refer to the Official Golang Docs . go build -o bin/aclapi ./cmd/aclapi Using Makefile \u00b6 For installing via Makefile, make sure you have make installed and follow the commands listed below. The Makefile will take care of all the building procdures as per your system. Just make sure that all the required dependences are installed (like Go, protoc, etc.) For installing make , follow the Official Page for GNU's make project make build 4. Useful Commands \u00b6 Build: make build Run: make run Test: make test Lint: make lint (requires golangci-lint) Clean: make clean ACL Core Daemon \u00b6 1. Getting the ACL Core Daemon \u00b6 Through Prebuilt Binaries \u00b6 The prebuilt binaries are available to install on GitHub Releases for the Linux ACL Management Project. Here are one line commands to install them for all the architectures. Make sure you have curl installed. For Linux x86_64 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclcore-linux-amd64 -o /usr/local/bin/aclcore chmod +x /usr/local/bin/aclcore For Linux ARM64 \u00b6 curl -L https://github.com/example-org/aclm/releases/latest/download/aclcore-linux-amd64 -o /usr/local/bin/aclcore chmod +x /usr/local/bin/aclcore Through GitHub Source Code \u00b6 Visit the Official GitHub Repository for Linux ACL Management System for the complete source code. To clone the repository from GitHub, use the following command. Make sure you have git installed on your system. git clone https://github.com/PythonHacker24/linux-acl-management-aclcore 2. Configuration \u00b6 When working with the Linux ACL Management System's ACL Core Daemon Component, all you need is the aclcore binary, aclcore.yaml with proper paramaters. The aclcore.yaml is the heart of the Linux ACL Management System ACL Core Daemon and contains all you need to setup the system. More about configuration here: link to config 3. Build \u00b6 There are currently 2 ways of building Linux ACL Management System ACL Core Daemon Component. You can build and run the aclcore using Go directly or the Makefile. Using Go \u00b6 Building through Go can be done through the Golang compiler with one command. Incase you don't have Go installed on your system, refer to the Official Golang Docs . go build -o bin/aclcore ./cmd/aclcore Using Makefile \u00b6 For installing via Makefile, make sure you have make installed and follow the commands listed below. The Makefile will take care of all the building procdures as per your system. Just make sure that all the required dependences are installed (like Go, protoc, etc.) For installing make , follow the Official Page for GNU's make project make build 4. Useful Commands \u00b6 Build: make build Run: make run Test: make test Lint: make lint (requires golangci-lint) Clean: make clean","title":"Installation"},{"location":"02_daemon_component/installation/#acl-api-daemon","text":"","title":"ACL API Daemon"},{"location":"02_daemon_component/installation/#1-getting-the-acl-api-daemon","text":"","title":"1. Getting the ACL API Daemon"},{"location":"02_daemon_component/installation/#through-prebuilt-binaries","text":"The prebuilt binaries are available to install on GitHub Releases for the Linux ACL Management Project. Here are one line commands to install them for all the architectures. Make sure you have curl installed.","title":"Through Prebuilt Binaries"},{"location":"02_daemon_component/installation/#for-linux-x86_64","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclapi-linux-amd64 -o /usr/local/bin/aclapi chmod +x /usr/local/bin/aclapi","title":"For Linux x86_64"},{"location":"02_daemon_component/installation/#for-linux-arm64","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclapi-linux-amd64 -o /usr/local/bin/aclapi chmod +x /usr/local/bin/aclapi","title":"For Linux ARM64"},{"location":"02_daemon_component/installation/#through-github-source-code","text":"Visit the Official GitHub Repository for Linux ACL Management System for the complete source code. To clone the repository from GitHub, use the following command. Make sure you have git installed on your system. git clone https://github.com/PythonHacker24/linux-acl-management-aclapi","title":"Through GitHub Source Code"},{"location":"02_daemon_component/installation/#2-configuration","text":"When working with the Linux ACL Management System's ACL API Daemon Component, all you need is the aclapi binary, aclapi.yaml with proper paramaters. The aclapi.yaml is the heart of the Linux ACL Management System ACL API Daemon and contains all you need to setup the system. More about configuration here: link to config","title":"2. Configuration"},{"location":"02_daemon_component/installation/#3-build","text":"There are currently 2 ways of building Linux ACL Management System ACL API Daemon Component. You can build and run the aclapi using Go directly or the Makefile.","title":"3. Build"},{"location":"02_daemon_component/installation/#using-go","text":"Building through Go can be done through the Golang compiler with one command. Incase you don't have Go installed on your system, refer to the Official Golang Docs . go build -o bin/aclapi ./cmd/aclapi","title":"Using Go"},{"location":"02_daemon_component/installation/#using-makefile","text":"For installing via Makefile, make sure you have make installed and follow the commands listed below. The Makefile will take care of all the building procdures as per your system. Just make sure that all the required dependences are installed (like Go, protoc, etc.) For installing make , follow the Official Page for GNU's make project make build","title":"Using Makefile"},{"location":"02_daemon_component/installation/#4-useful-commands","text":"Build: make build Run: make run Test: make test Lint: make lint (requires golangci-lint) Clean: make clean","title":"4. Useful Commands"},{"location":"02_daemon_component/installation/#acl-core-daemon","text":"","title":"ACL Core Daemon"},{"location":"02_daemon_component/installation/#1-getting-the-acl-core-daemon","text":"","title":"1. Getting the ACL Core Daemon"},{"location":"02_daemon_component/installation/#through-prebuilt-binaries_1","text":"The prebuilt binaries are available to install on GitHub Releases for the Linux ACL Management Project. Here are one line commands to install them for all the architectures. Make sure you have curl installed.","title":"Through Prebuilt Binaries"},{"location":"02_daemon_component/installation/#for-linux-x86_65","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclcore-linux-amd64 -o /usr/local/bin/aclcore chmod +x /usr/local/bin/aclcore","title":"For Linux x86_64"},{"location":"02_daemon_component/installation/#for-linux-arm64_1","text":"curl -L https://github.com/example-org/aclm/releases/latest/download/aclcore-linux-amd64 -o /usr/local/bin/aclcore chmod +x /usr/local/bin/aclcore","title":"For Linux ARM64"},{"location":"02_daemon_component/installation/#through-github-source-code_1","text":"Visit the Official GitHub Repository for Linux ACL Management System for the complete source code. To clone the repository from GitHub, use the following command. Make sure you have git installed on your system. git clone https://github.com/PythonHacker24/linux-acl-management-aclcore","title":"Through GitHub Source Code"},{"location":"02_daemon_component/installation/#2-configuration_1","text":"When working with the Linux ACL Management System's ACL Core Daemon Component, all you need is the aclcore binary, aclcore.yaml with proper paramaters. The aclcore.yaml is the heart of the Linux ACL Management System ACL Core Daemon and contains all you need to setup the system. More about configuration here: link to config","title":"2. Configuration"},{"location":"02_daemon_component/installation/#3-build_1","text":"There are currently 2 ways of building Linux ACL Management System ACL Core Daemon Component. You can build and run the aclcore using Go directly or the Makefile.","title":"3. Build"},{"location":"02_daemon_component/installation/#using-go_1","text":"Building through Go can be done through the Golang compiler with one command. Incase you don't have Go installed on your system, refer to the Official Golang Docs . go build -o bin/aclcore ./cmd/aclcore","title":"Using Go"},{"location":"02_daemon_component/installation/#using-makefile_1","text":"For installing via Makefile, make sure you have make installed and follow the commands listed below. The Makefile will take care of all the building procdures as per your system. Just make sure that all the required dependences are installed (like Go, protoc, etc.) For installing make , follow the Official Page for GNU's make project make build","title":"Using Makefile"},{"location":"02_daemon_component/installation/#4-useful-commands_1","text":"Build: make build Run: make run Test: make test Lint: make lint (requires golangci-lint) Clean: make clean","title":"4. Useful Commands"},{"location":"02_daemon_component/quick_start/","text":"Introduction \u00b6 The Daemon component is installed on Linux file servers which serves a file system like NFS which doesn't allow ACL changes to be applied on the mount point and requires manual modifications from the server's console itself. This daemon is managed by the backend component, which communicates with the daemon through gRPC framework. This component is divided into 2 daemons, ACL API Daemon and ACL Core Daemon . ACL API Daemon \u00b6 The ACL API daemon is responsible for communicated with the backend server, recieving ACL modification requests at it's gRPC endpoint, and comminicating with the ACL Core Daemon to modify the permissions as well as return the results of the operation back the the backend server. It runs on the least privilege user for security purposes since it's exposed to the external network with gRPC. Get the source code on the Official GitHub Repository . ACL Core Daemon \u00b6 The ACL Core daemon is responsible for executing ACL modifications with setfacl and communicating with ACL API Daemon with Unix sockets. It runs as a root user or as a user which has the permissions to execute setfacl on behalf of other users. It's protected from any other processes (for example, it has no access the any network interface). Get the source code on the Official GitHub Repository .","title":"Quick Start"},{"location":"02_daemon_component/quick_start/#introduction","text":"The Daemon component is installed on Linux file servers which serves a file system like NFS which doesn't allow ACL changes to be applied on the mount point and requires manual modifications from the server's console itself. This daemon is managed by the backend component, which communicates with the daemon through gRPC framework. This component is divided into 2 daemons, ACL API Daemon and ACL Core Daemon .","title":"Introduction"},{"location":"02_daemon_component/quick_start/#acl-api-daemon","text":"The ACL API daemon is responsible for communicated with the backend server, recieving ACL modification requests at it's gRPC endpoint, and comminicating with the ACL Core Daemon to modify the permissions as well as return the results of the operation back the the backend server. It runs on the least privilege user for security purposes since it's exposed to the external network with gRPC. Get the source code on the Official GitHub Repository .","title":"ACL API Daemon"},{"location":"02_daemon_component/quick_start/#acl-core-daemon","text":"The ACL Core daemon is responsible for executing ACL modifications with setfacl and communicating with ACL API Daemon with Unix sockets. It runs as a root user or as a user which has the permissions to execute setfacl on behalf of other users. It's protected from any other processes (for example, it has no access the any network interface). Get the source code on the Official GitHub Repository .","title":"ACL Core Daemon"},{"location":"02_daemon_component/troubleshooting/","text":"Info: Troubleshooting would be written once enough issues occur while using the system and solutions are created to tackle them.","title":"Troubleshooting"},{"location":"03_frontend_component/architecture/","text":"","title":"Architecture"},{"location":"03_frontend_component/changelog/","text":"","title":"Changelog"},{"location":"03_frontend_component/development/","text":"","title":"Development"},{"location":"03_frontend_component/installation/","text":"Frontend Quick Start \u00b6 This guide will help you get up and running quickly, whether you\u2019re developing locally or deploying in a containerized environment. Prerequisites \u00b6 Node.js (LTS): 20.x or 22.x recommended npm: 10+ (bundled with Node.js) 1. Getting Frontend Component \u00b6 Clone the repository and enter the project directory: git clone <repo-url> frontend cd vortex-frontend Ensure Node.js (LTS 20.x or 22.x) and npm are installed: node -v npm -v 2. Configuration \u00b6 Create a .env.local file in the project root with your API endpoints: # Required: API base URL (defaults to http://localhost:8080 if omitted) NEXT_PUBLIC_API_BASE_URL=http://localhost:8080 # Optional: WebSocket base URL (auto-derived from API if omitted) # For http://localhost:8080 this becomes ws://localhost:8080 # Set explicitly only if you need a different host/protocol: # NEXT_PUBLIC_WS_BASE_URL=ws://localhost:8080 3. Deploy in Development Mode \u00b6 Install dependencies: npm install Start the dev server (Turbopack): npm run dev Open http://localhost:3000 Tips: Ensure your backend is reachable at NEXT_PUBLIC_API_BASE_URL. Update .env.local and restart the dev server if you change variables 4. Deploy in Production Mode \u00b6 Set production environment variables export NEXT_PUBLIC_API_BASE_URL=https://your-api.example.com # Optional: # export NEXT_PUBLIC_WS_BASE_URL=wss://your-api.example.com Install clean deps, build, and start: npm ci npm run build npm run start -p 3000 Notes: NEXT_PUBLIC_* variables are inlined at build time. Set them before npm run build. Ensure the API/WebSocket endpoints are reachable from the deployed environment.","title":"Installation"},{"location":"03_frontend_component/installation/#frontend-quick-start","text":"This guide will help you get up and running quickly, whether you\u2019re developing locally or deploying in a containerized environment.","title":"Frontend Quick Start"},{"location":"03_frontend_component/installation/#prerequisites","text":"Node.js (LTS): 20.x or 22.x recommended npm: 10+ (bundled with Node.js)","title":"Prerequisites"},{"location":"03_frontend_component/installation/#1-getting-frontend-component","text":"Clone the repository and enter the project directory: git clone <repo-url> frontend cd vortex-frontend Ensure Node.js (LTS 20.x or 22.x) and npm are installed: node -v npm -v","title":"1. Getting Frontend Component"},{"location":"03_frontend_component/installation/#2-configuration","text":"Create a .env.local file in the project root with your API endpoints: # Required: API base URL (defaults to http://localhost:8080 if omitted) NEXT_PUBLIC_API_BASE_URL=http://localhost:8080 # Optional: WebSocket base URL (auto-derived from API if omitted) # For http://localhost:8080 this becomes ws://localhost:8080 # Set explicitly only if you need a different host/protocol: # NEXT_PUBLIC_WS_BASE_URL=ws://localhost:8080","title":"2. Configuration"},{"location":"03_frontend_component/installation/#3-deploy-in-development-mode","text":"Install dependencies: npm install Start the dev server (Turbopack): npm run dev Open http://localhost:3000 Tips: Ensure your backend is reachable at NEXT_PUBLIC_API_BASE_URL. Update .env.local and restart the dev server if you change variables","title":"3. Deploy in Development Mode"},{"location":"03_frontend_component/installation/#4-deploy-in-production-mode","text":"Set production environment variables export NEXT_PUBLIC_API_BASE_URL=https://your-api.example.com # Optional: # export NEXT_PUBLIC_WS_BASE_URL=wss://your-api.example.com Install clean deps, build, and start: npm ci npm run build npm run start -p 3000 Notes: NEXT_PUBLIC_* variables are inlined at build time. Set them before npm run build. Ensure the API/WebSocket endpoints are reachable from the deployed environment.","title":"4. Deploy in Production Mode"},{"location":"03_frontend_component/quick_start/","text":"Introduction \u00b6 The frontend component serves as the user facing component for Vortex. It helps users log in and interact with all the file permissions. It is highly decoupled with the backend and does not have any control over the infrastructure. All the interactions scheduled are processed by the backend. Hence, frontend is the zero-trust component in this system. Get the source code on the Official GitHub Repository .","title":"Quick Start"},{"location":"03_frontend_component/quick_start/#introduction","text":"The frontend component serves as the user facing component for Vortex. It helps users log in and interact with all the file permissions. It is highly decoupled with the backend and does not have any control over the infrastructure. All the interactions scheduled are processed by the backend. Hence, frontend is the zero-trust component in this system. Get the source code on the Official GitHub Repository .","title":"Introduction"},{"location":"03_frontend_component/troubleshooting/","text":"Info: Troubleshooting would be written once enough issues occur while using the system and solutions are created to tackle them.","title":"Troubleshooting"}]}